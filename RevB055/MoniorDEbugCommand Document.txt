unimonの機能強化

unimonは多数のCPU上で動くように設計されています。
EMUZ80_Monitorは、unimonのZ80版をベースにデバッグ機能を強化したものです。
unimonをカスタマイズするにあたって、unimon-20220811版を使用しています。
また、emuz80はI/O空間が無いので、関係するOコマンドとPコマンドは削除しました。

＜Rev.B03での注意点＞

・メモリの関係で、PIC18F47Q84（またはQ83)でしか動かすことが出来ません。
・ROMエリアは32K必要となります。

　　CLCをカスタマイズしているファームウェアでモニタを動作させる場合、
　　ROMを32Kまで認識するように変更する必要があります。

　　サンプルで提供しているRAM8K版のファームウェアは、電脳伝説さんのオリジナル
　　ファームをROM16KからROM32Kに変更してあります。


＜Rev.B03で追加された機能＞

・アセンブルコマンド（Minimal Assembler)

　　A[<address>] 
　　
　　　指定したアドレスから、センブルモードになります

　　　.<cr>　　アセンブルモードから、モニタに戻ります。
　　　
＜Minimal Assemblerの仕様＞

ニモニックは、Z80アセンブラの仕様に従います。

＜数字の扱い＞
・数字は10進数、16進数を扱うものとする。
・A〜Fで始まる数字には、前に0を付ける。
・16進数は末尾にＨを付ける。
・数字は16ビット長で扱われる。０〜65535
・数字の助長入力は７文字以上はエラーとなる。（最大0FFFFHの6文字）
・有効ビット長が8ビットの場合、16ビット長の下位8ビットが有効で上位8ビットは無視される

＜疑似命令＞
３つだけ、サポートしました。

１．ORG <address>

指定されたアドレスへロケーションカウンタを進めます。

２．DB [1バイト数値 | "文字列"]

1バイトの数値入力、または、"文字列"を入力します。
DBはサブセットです。「,」で区切っての複数入力はサポートしていません。

３．DW

2バイトの数値入力。
DWはサブセットです。「,」で区切っての複数入力はサポートしていません。

＜計算式＞
サポートしていません。

＜リラティブ数値の入力について＞

JR、DJNZで指定するリラティブ数値は、目的のアドレスを入力することで、自動的に計算されます。
指定アドレスが範囲外の場合、エラーとなります。


＜Rev.B02で追加された機能＞

・逆アセンブルコマンド（Disassemble）

　　DI[<adr>][,s<steps>|<adr>]

　　　　指定したアドレスから、指定したアドレスもしくは指定したステップ数（10進）を
　　　　逆アセンブルし、表示します。
　　　　アドレス、ｽﾃｯﾌﾟ指定を省略した場合、直前に逆アセンブル終了したアドレスから
　　　　１０ステップ表示します。表示中に何かキーを入力すると、表示を終了します。
　　　　
　　　　(例）
　　　　　　DIc000,s30<cr>　　　　C000H番地から30ステップ逆アセンブルします。
　　　　　　DIc000, c010<cr>　　　C000H番地からC010番地まで逆アセンブルします。
　　　　　　DI<cr>　　　　　　　　直前に終了したアドレスから10ステップ逆アセンブルします。
　　　　　　DIc000<cr>　　　　　　C000H番地から10ステップ逆アセンブルします。

＜仕様変更＞

ブレークポイントを指定したアドレスをトレースするときに、ブレークポイントが優先され
トレース出来ませんでした。使い勝手が良くない為、トレースを優先し、ブレークポイントを指定
しているアドレスを実行できるように、仕様変更しました。



＜強化した部分＞

・Gコマンド

　　G[addr][,stop addr]
　　
　　　　ストップアドレスの指定を追加
　　　　ストップアドレスでモニタに制御が戻ります。
　　　　制御が戻った時に、レジスタを表示します。
　　　　ROM内のアドレスでストップさせることは出来ません。


・Lコマンド

　　動作終了まで無反応だったので、HEXファイルの１ライン入力毎に「．」を表示
　　するように変更しました。


・LGコマンド

　　ヘキサファイルのロード後、ロードアドレスの先頭にジャンプします。


・Rコマンド

　　F,F'レジスタを数値ではなく、ビジュアル化し直観視でフラグの状態が分かるよう
　　にしました。


＜コマンド＞

・?コマンドヘルプ

　コマンドヘルプで以下のヘルプが表示されます。
　
　　? :Command Help
　　#L|<num> :Launch program
　　A[<address>] : Mini Assemble mode
　　B[1|2[,<adr>]] :Set or List Break Point
　　BC[1|2] :Clear Break Point
　　D[<adr>] :Dump Memory
　　DI[<adr>][,s<steps>|<adr>] :Disassemble
　　G[<adr>][,<stop adr>] :Go and Stop
　　L[G|<offset>] :Load HexFile (and GO)
　　P[I|S] :Save HexFile(I:Intel,S:Motorola)
　　R[<reg>] :Set or Dump register
　　S[<adr>] :Set Memory
　　T[<adr>][,<steps>|-1] : Trace command
　　TM[I|S] :Trace Option for CALL
　　TP[ON|OFF] :Trace Print Mode



・Bコマンド（ブレークポイント設置関係）

　　b[1 | 2 [ ,break point address]]

　　ブレイクポイント設置コマンド。2か所設定できます。分岐を考えると、
　　とりあえず2か所あればよいかと・・・
　　プログラムを実行すると、ブレークポイントでモニタに制御が戻ります。
　　戻った時に、レジスタの表示を行います。
　　break point addressの指定が無い時は、現在のブレークポイントの状態を
　　表示します。
　　ROM内にブレークポイントを設定することは出来ません。

　　　　（例）
　　　　] b1,c000<cr>
　　　　] b2,c001<cr>

　　　　] b<cr>
　　　　BP(1):C000
　　　　BP(2):C001

　　　　] b1<cr>
　　　　BP(1):C00

　　bc[1 | 2]

　　　　ブレークポイントの解除
　　　　パラメータ指定なしの時は、ブレークポイント2ヶ所とも解除

・Tコマンド（トレースコマンド関係）

　　t[address][,step数]

　　指定されたアドレスから指定ステップ実行する。ステップ数（10進数）を省略する
　　と、1ステップトレースする。アドレスを省略すると、現在のPCアドレスから
　　トレースする。ROM内をトレースすることは出来ません。

　　注）RST命令は、monitorで予約されているため、RST命令の次の命令までトレース
　　できません。（RST命令実行し、リターン後にトレース続行となる）

　　　　（例）
　　　　] t cooo, 10<cr>　　　　C000H番地から10ステップ実行し、モニタに戻ります。
　　　　　　　　　　　　　　　　モニタに戻るとレジスタ表示し、PCのアドレスを
　　　　　　　　　　　　　　　　逆アセンブルし表示します。（TP ON 時）

　　step数に-1を指定すると、無限トレースモードとなりCTL+Cキーで中断するまで
　　トレースを実行し続けます。
　　
　　　　例）
　　　　] t -1　　　　現在のPCのアドレスからCtl+cが押されるまでトレースを続ける。

　　tp [on | off]

　　トレース実行後のレジスタ表示のON,OFFを制御します。パラメータ省略時は、
　　表示モードを表示します。初期値は表示モード(tp on)

　　tm [i | s]
　　
　　CALL命令のトレースモードの制御を行います。[i | s]省略時は、現在のトレース
　　モードを表示します。
　　(初期値)はステップインモード(tm i)
　　
　　　　　] tm i<cr>  　　　　　　ステップインモード。CALLが実行された先のアド
　　　　　レスをトレースします。
　　　　　] tm s<cr>  　　　　　　スキップモード。CALL命令を実行し、リターン後
　　　　　　　　　　　　　　　　　にトレース続行となります。
　　　　　　　　　　　　　　　　　この機能を使うと、call先がROMでも実行できます。
　　　　　　　　　　　　　　　　　（ROM内CALL実行し、リターン後にトレース続行）


・#コマンド（アプリローンチ）

emuz802は大容量？のROMを抱えた形になっているので、Basicだけではなく、いくつかソ
フトを組み込むんであります。

　　#L<cr>

　　登録ソフトの表示

	1. GBASIC Start"
	2. GBASIC Restart"
	3. Palo Alto Tiny BASIC Start
	4. Palo Alto Tiny BASIC Restart"
	5. GAME80 Start
	6. GAME80 Restart
	7. VTL Start
	8. VTL Restart

　　と表示されます。

　　#番号<cr>

　　選択したソフトを実行します。


・アセンブルコマンド（Minimal Assemble)

　　A[<address>] 
　　
　　　指定したアドレスから、センブルモードになります

　　　.<cr>　　アセンブルモードから、モニタに戻ります。
　　　
＜Minimal Assemblerの仕様＞

ニモニックは、Z80アセンブラの仕様に従います。

＜数字の扱い＞
・数字は10進数、16進数を扱うものとする。
・A〜Fで始まる数字には、前に0を付ける。
・16進数は末尾にＨを付ける。
・数字は16ビット長で扱われる。０〜65535
・数字の助長入力は７文字以上はエラーとなる。（最大0FFFFHの6文字）
・有効ビット長が8ビットの場合、16ビット長の下位8ビットが有効で上位8ビットは無視される

＜疑似命令＞
３つだけ、サポートしました。

１．ORG <address>

指定されたアドレスへロケーションカウンタを進めます。

２．DB [1バイト数値 | "文字列"]

1バイトの数値入力、または、"文字列"を入力します。
DBはサブセットです。「,」で区切っての複数入力はサポートしていません。

３．DW

2バイトの数値入力。
DWはサブセットです。「,」で区切っての複数入力はサポートしていません。

＜計算式＞
サポートしていません。

＜リラティブ数値の入力について＞

JR、DJNZで指定するリラティブ数値は、目的のアドレスを入力することで、自動的に計算されます。
指定アドレスが範囲外の場合、エラーとなります。


以上．

